package dumper

import (
	"bytes"
	"testing"
)

func TestReadPersistentValuesStartupMessage(t *testing.T) {
	out := new(bytes.Buffer)
	dumper := &PgDumper{
		logger: NewTestLogger(out),
	}
	in := []byte{
		0x00, 0x00, 0x00, 0x52, 0x00, 0x03, 0x00, 0x00, 0x75, 0x73, 0x65, 0x72, 0x00, 0x70, 0x6f, 0x73,
		0x74, 0x67, 0x72, 0x65, 0x73, 0x00, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x00, 0x74,
		0x65, 0x73, 0x74, 0x64, 0x62, 0x00, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
		0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x70, 0x73, 0x71, 0x6c, 0x00, 0x63, 0x6c, 0x69, 0x65,
		0x6e, 0x74, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00, 0x55, 0x54, 0x46, 0x38,
		0x00, 0x00,
	}

	actual := dumper.ReadPersistentValues(in)
	expected := []DumpValue{
		DumpValue{
			Key:   "username",
			Value: "postgres",
		},
		DumpValue{
			Key:   "database",
			Value: "testdb",
		},
	}

	if len(actual) != len(expected) {
		t.Errorf("actual %v\nwant %v", actual, expected)
	}
	if actual[0] != expected[0] {
		t.Errorf("actual %v\nwant %v", actual, expected)
	}
	if actual[1] != expected[1] {
		t.Errorf("actual %v\nwant %v", actual, expected)
	}
}
